// Generated by Flexc++ V0.98.00 on Tue, 26 Feb 2013 15:00:00 -0800

// $insert class_h
#include "SymbolTable.h"
#include "Scanner.h"
#include "Parser.h"
#include <fstream>

void Scanner::scannerError()
{
	// case : empty file : TODO

	// location.print();

	//
	//		Get The Line The Bad Lexeme Is On
	//
	std::string t = nextLine();

	//
	//		Output The Line With The Bad Lexeme Is On
	//
	size_t number_of_tabs = 0;
	for(auto c : t ) {
		// print the character as it is unless it's a tab
		if (c!='\t') {
			std::cerr << c;
		}
		// print the tab by spaces
		else {
			number_of_tabs++;
			for(int i=0;i<tabWidth;i++) {
				std::cerr << " ";
			}
		}
	}
	std::cerr << std::endl;

	//
	//		Point To The Bad Lexeme With ^ On The Following Line
	//
	size_t number_of_spaces = number_of_tabs*(tabWidth-1)+location.cnum-1;
	for(size_t i=0;i<number_of_spaces;i++) {
		std::cerr << " ";
	}
	std::cerr << "^";
	
	std::cerr << "Lexical Error @ Line: " << location.lnum << ":" << location.cnum << std::endl;
	
	// terminate the program
	exit(0);

}

std::string Scanner::lastLine()
{
	// save stream position
	std::streampos savepos = ref_istream->tellg();

	//
	//		Get The Last Line
	//
	std::string lastLine;
	if (location.lastNewlinePos<0) {
		ref_istream->seekg(0, ref_istream->beg);
	}
	else { // if (location.lastNewlinePos>=0) {
		ref_istream->seekg(location.lastNewlinePos+1, ref_istream->beg);
	}
	std::getline(*ref_istream, lastLine);

	// restore stream position
	ref_istream->seekg(savepos);

	// return
	return lastLine;
}

std::string Scanner::nextLine()
{
	// save stream position
	std::streampos savepos = ref_istream->tellg();

	//
	//		Get The Next Line
	//
	std::string lastLine;
	if (location.currNewLinePos<0) {
		ref_istream->seekg(0, ref_istream->beg);
	}
	else if (location.currNewLinePos>=0) {
		ref_istream->seekg(location.currNewLinePos+1, ref_istream->beg);
	}
	std::getline(*ref_istream, lastLine);

	// restore stream position
	ref_istream->seekg(savepos);

	// return
	return lastLine;
}

// Obsolete. Parser should run scanner.
void Scanner::run()
{
	int val = lex();
	while ( val != Parser::ENDOFFILE ) {

		// Lexer Debug
		if (debug.lexer_dump)
			(*debug.lexerDumpTo) << matched() << " : " << val << std::endl;

		// Token File
		if (debug.token_dump) {
			debug.token_file_stream	<<  matched() << std::endl;
		}

		// update
		val = lex();
	}

}

void Scanner::update()
{
	updateLocation();

	// output line by line if the debug option is true
	//
	// If the parser is running as well, the line is output AFTER the 
	// reduction is done as much as possible on that line
	if (debug.output_line_by_line && debug.lineOutputTo) {
		if (matched() == "\n") {
			*(debug.lineOutputTo) 
				<< "---------------------------------------------------------- " << std::endl
				<< "l" << location.lnum << " : " 
				<< lastLine() << std::endl
				<< "---------------------------------------------------------- " << std::endl
				<< std::endl; 
		}
	}

	// TODO 
	// If parser runs `int Scanner::lex()`, then this Scanner does not have
	// access to the int return value (val variable below).
	// 
	//      Lexer Debug
	//
	// if (debug.lexer_dump && debug.lexerDumpTo) {
	// 	(*debug.lexerDumpTo) << matched() << " : " << val << std::endl;
	// }

}

void Scanner::updateLocation()
{
	std::string mstr(matched());
	if ( mstr == "\n" ) {

		location.lastNewlinePos = location.currNewLinePos;
		location.currNewLinePos = location.numBytesRead;

		location.lnum++; 
		location.cnum = 1;

	}
	else {
		location.cnum += mstr.size();
	}
	location.numBytesRead += mstr.size();
	
}

void Scanner::dumpSymbolTable()
{

	stab->dumpTable( "symboltable.txt" );

}

void Scanner::setDebugLineByLine(std::ostream& lineOutputTo)
{
	if ( lineOutputTo.good() ) {
		debug.output_line_by_line = true;
		debug.lineOutputTo = &lineOutputTo;
	}
	else {
		std::cerr << "setDebugLineByLine() : ostream not good" << std::endl;
		// throw something here
	}
}

void Scanner::setDebugSymbolTableDump(const std::string& filename)
{
	debug.symbol_table_dump = true;
	debug.symbol_table_dump_file = filename;
}

// void Scanner::setDebugSymbolTableDump(std::ostream& symbolTableDumpTo)
// {
// 	if ( symbolTableDumpTo.good() ) {
// 		debug.symbol_table_dump = true;
// 		debug.symbolTableDumpTo = &symbolTableDumpTo;
// 	}
// 	else {
// 		std::cerr << "setDebugSymbolTableDump() : the stream supplied is not good." << std::endl;
// 		// throw or exit here
// 	}
// }

void Scanner::setDebugLexer(std::ostream& lexerDumpTo)
{
	if ( lexerDumpTo.good() ) {
		// std::cout << "Setting up lexer dump" << std::endl;
		debug.lexer_dump = true;
		debug.lexerDumpTo = &lexerDumpTo;
	}
	else {
		std::cerr << "setDebugSymbolTableDump() : the stream supplied is not good." << std::endl;
		// throw or exit here
	}
}

void Scanner::setDebugToken(const std::string& filename)
{
	debug.token_dump = true;	
	debug.token_dump_file = filename;
	debug.token_file_stream.open(filename);
	if(!debug.token_file_stream.good()) {
		std::cerr << filename 
			<< "scannersetDebugToken() : Could not open file"  << filename
			<< std::endl;
	}
}
