// Generated by Bisonc++ V4.01.00 on Tue, 26 Feb 2013 14:54:58 -0800

#ifndef Parser_h_included
#define Parser_h_included

// $insert baseclass
#include "Parserbase.h"
#include "Scanner.h"
#include "SymbolTable.h"

#undef Parser
class Parser: public ParserBase
{
		
	
	public:
		int parse();

		Parser( std::istream& stream, SymbolTable* table )
		{

			scanner = new Scanner( stream );

			symbolTable = table;

		}

		Parser( Scanner& s, SymbolTable* table ) 
			: scanner(&s), symbolTable(table)
		{}

		LTYPE__* getLocationStruct()
		{

			return &d_loc__;

		}

		void configDebugPrint(
			std::ostream& os, std::string prefix="", std::string postfix="");


	private:
		void error(char const *msg);	// called on (syntax) errors
		int lex();						// returns the next token from the
										// lexical scanner. 
		void print();					// use, e.g., d_token, d_loc
		void debugPrint(std::string);

		struct ParserDebug {
			ParserDebug() 
				: debugOutput(false), debugOutputStream(std::cout.rdbuf())
			{}

			bool debugOutput;
			std::string debugOutputPrefix;
			std::string debugOutputPostfix;
			std::ostream debugOutputStream;
		};

		ParserDebug debug;
		Scanner* scanner;
		SymbolTable* symbolTable;

		Symbol currentDeclaration;

		//
		//      Declaration Related
		//
		// 	TODO : create another class for this?
		//		

		void beginDeclarationSection()
		{
			std::cout << "implement beginDeclarationSection() " << std::endl;	
		}
		void endDeclarationSection()      
		{ 
			std::cout << "implement endDeclarationSection() " << std::endl;	
		}
		void declare()                    
		{
			std::cout << "implement declare()" << std::endl;
		}
		void determineType()              
		{
			std::cout << "implement determineType()" << std::endl;
		}
		void initializeArray()            
		{
			std::cout << "implement initializeArray()" << std::endl;
		}
		void addValueToArray()            
		{
			std::cout << "implement addValueToArray()" << std::endl;
		}
		void declareIdentifier()          
		{
			std::cout << "implement declareIdentifier()" << std::endl;
		}
		void setDeclarationLocation();
		void addTypeSpecifier()      
		{
			std::cout << "implement addTypeSpecifier()" << std::endl;
		}

		void setConst()              
		{
			std::cout << "implement setConst()" << std::endl;
		}

		void setVolitle()            
		{
			std::cout << "implement setVolitle()" << std::endl;
		}
		void specifyArray()          
		{
			std::cout << "implement specifyArray()" << std::endl;
		}
		void specifyFunction()       
		{
			std::cout << "implement specifyFunction()" << std::endl;
		}
		void specifyFunctionCall()   
		{
			std::cout << "implement specifyFunctionCall()" << std::endl;
		}




















		bool isUseless(int token);	

		// support functions for parse():
			void executeAction(int ruleNr);
			void errorRecovery();
			int lookup(bool recovery);
			void nextToken();
			void print__();
};


#endif
