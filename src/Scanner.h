// Generated by Flexc++ V0.98.00 on Tue, 26 Feb 2013 15:00:00 -0800

#ifndef Scanner_H_INCLUDED_
#define Scanner_H_INCLUDED_

// $insert baseclass_h
#include "Scannerbase.h"
#include "SymbolTable.h"
#include <string>


class Parser;

struct Loc {
    Loc() 
        : lnum(1), cnum(1)
    {} 
    int lnum; // line number
    int cnum; // column number
};

// $insert classHead
class Scanner: public ScannerBase
{
    public:
        explicit Scanner(std::istream &in = std::cin,
                                std::ostream &out = std::cout);

	Scanner(SymbolTable*, std::istream &in = std::cin, std::ostream &out = std::cout);

    	explicit Scanner(SymbolTable*);

        Scanner(std::string const &infile, std::string const &outfile);

        Scanner(std::istream &in, std::ostream &out, Parser* parser );

	// Prints the line the bad lexeme is on and points to to the bad lexeme.
	//  
	// Call this function when a bad lexeme is found.
	// This function assumes updateLocation() keeps track of
	// lnum,cnum,lastNewlinePos. Don't call updateLocation() when bad
	// lexeme is found since that updates the location to the next lexeme.
        void scannerError();

        void commentHandler();

	// This function keeps track of the location of lexeme.
	//
	// After callling this function, location (member variable) refers to
	// the location of the next lexeme to be consumed by line number and
	// column number :
	//
	//	locatoin.lnum  and location.cnum
	//
	// lastNewlinePos is the zero-indexed offset of the last newline
	// character from the beginning of the file.
	//
	//	lastNewlinePos and numBytesRead
	// 
	void updateLocation();

        Loc& getLoc() { return location; }

        void dumpSymbolTable();

        static const int tabWidth = 4;

        // $insert lexFunctionDecl
        int lex();


    private:

	int lastNewlinePos; // 0-indexed

	int numBytesRead;

        Loc location; // current location

        // std::string lineValue;

        int lex__();

        int executeAction__(size_t ruleNr);

        Parser* parser;

        void print();

        void preCode();     // re-implement this function for code that must 
                            // be exec'ed before the patternmatching starts

	SymbolTable* stab;
    std::istream* ref_istream;
};

// $insert scannerConstructors
inline Scanner::Scanner(std::istream &in, std::ostream &out)
: numBytesRead(0), lastNewlinePos(-1), ScannerBase(in, out), ref_istream(&in)
{}


inline Scanner::Scanner(SymbolTable* tab, std::istream &in, std::ostream &out)
: numBytesRead(0), lastNewlinePos(-1), ScannerBase(in, out), stab(tab), ref_istream(&in)
{}


// $insert scannerConstructors
inline Scanner::Scanner(std::istream &in, std::ostream &out, Parser* parser )
: numBytesRead(0),
    lastNewlinePos(-1), ScannerBase(in, out), ref_istream(&in)
{
	this->parser = parser;
}



inline Scanner::Scanner(std::string const &infile, std::string const &outfile)
: numBytesRead(0),
    lastNewlinePos(-1), ScannerBase(infile, outfile)
{}

// $insert inlineLexFunction
inline int Scanner::lex()
{
    return lex__();
}

inline void Scanner::preCode() 
{
    // optionally replace by your own code
}

inline void Scanner::print() 
{
    print__();
}


#endif // Scanner_H_INCLUDED_

