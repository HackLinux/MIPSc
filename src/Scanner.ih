// Generated by Flexc++ V0.98.00 on Tue, 26 Feb 2013 15:00:00 -0800

// $insert class_h
#include "Scanner.h"
#include "Parser.h"
#include <fstream>

void Scanner::scannerError()
{
	// case : empty file : TODO

	// Get the line the bad lexeme is on
	std::string t;
	// case : bad lexeme is on the first line (before the first newline)
	if (lastNewlinePos<0) {
		ref_istream->seekg(0, ref_istream->beg);
	}
	// case : bad lexeme is on the second line or after (after the first newline)
	else if (lastNewlinePos>=0) {
		ref_istream->seekg(lastNewlinePos+1, ref_istream->beg);
	}
	std::getline(*ref_istream, t);

	// Output the line with the bad lexeme
	size_t number_of_tabs = 0;
	for(auto c : t ) {
		// print the character as it is unless it's a tab
		if (c!='\t') {
			std::cerr << c;
		}
		// print the tab by spaces
		else {
			number_of_tabs++;
			for(size_t i=0;i<tabWidth;i++) {
				std::cerr << " ";
			}
		}
	}
	std::cerr << std::endl;

	// Point to the bad lexeme with ^ on the following line
	size_t number_of_spaces = number_of_tabs*(tabWidth-1)+location.cnum-1;
	for(size_t i=0;i<number_of_spaces;i++) {
		std::cerr << " ";
	}
	std::cerr << "^";
	
	std::cerr << "Lexical Error @ Line: " << location.lnum << ":" << location.cnum << std::endl;
	
	// terminate the program
	exit(0);

}

void Scanner::updateLocation()
{
    std::string mstr(matched());
    if ( mstr == "\n" ) {

		lastNewlinePos = numBytesRead;

        location.lnum++; 
        location.cnum = 1;

    }
    else {
        location.cnum += mstr.size();
    }
	numBytesRead += mstr.size();
   	
}



void Scanner::dumpSymbolTable()
{

	stab->dumpTable( "symboltable.txt" );

}
